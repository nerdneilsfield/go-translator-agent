# An Optimized FPGA-Based Real-Time NDT for 3D-LiDAR Localization in Smart Vehicles  

Qi Deng , Member, IEEE, Hao Sun , Graduate Student Member, IEEE, Fupeng Chen, Graduate Student Member, IEEE, Yuhao $\mathrm{Shu}^{\oplus}$ , Graduate Student Member, IEEE, Hui Wang, and Yajun $\mathrm{Ha}^{\mathbb{P}}$ , Senior Member, IEEE  

Abstract—Light detection and ranging (LiDAR) based normal distribution transform (NDT) is a popular localization algorithm in smart vehicles for its robustness and accuracy. To meet the requirement of higher speed of smart vehicles, LiDAR point clouds become increasingly large due to the increase of not only the number of laser channels but also their frame rates. However, previous NDT implementations fail to achieve realtime performance when handling large point clouds because they require an enormous number of search operations and perform intensive computations per search operation. To address this issue, we propose an optimized NDT algorithm and its FPGA implementation. First, we effectively speed up each search operation by proposing a new non-recursive and memory-efficient data structure, called occupation-aware-voxel-structure (OAVS). Second, we significantly reduce the number of search operations by removing redundant searches with an optimized semanticassisted OAVS-based NDT algorithm (SEO-NDT). Third, we further improve the real-time and energy efficiency by proposing a streaming FPGA accelerator architecture for SEO-NDT. Compared with the state-of-the-art embedded CPU and GPU implementations, our FPGA implementation achieves up to $35.85\mathbf{x}$ and 2.44x execution time speed up, respectively.  

Index Terms—Smart vehicles, localization, FPGA, real-time, energy-efficient, 3D LiDAR, 3D point cloud.  

Manuscript received March 22, 2021; revised May 25, 2021; accepted June 15, 2021. Date of publication July 8, 2021; date of current version August 30, 2021. This work was supported by the Science and Technology Commission of Shanghai Municipality under Grant 19511131200. This brief was recommended by Associate Editor M. Huang. (Corresponding author: Yajun Ha.)  

Qi Deng is with the Shanghai Advanced Research Institute, Chinese Academy of Sciences, Shanghai 200050, China, also with the School of Information Science and Technology, ShanghaiTech University, Shanghai 201210, China, and also with the University of Chinese Academy of Sciences, Beijing 100049, China.  

Hao Sun, Fupeng Chen, and Yuhao Shu are with the School of Information Science and Technology, ShanghaiTech University, Shanghai 201210, China, also with the Shanghai Institute of Microsystem and Information Technology, Chinese Academy of Sciences, Shanghai 200050, China, and also with the School of Electronic, Electrical and Communication Engineering, University of Chinese Academy of Sciences, Beijing 100049, China.  

Hui Wang is with the Microelectronics, Shanghai Advanced Research Institute, Chinese Academy of Sciences, Shanghai 200050, China.  

Yajun Ha is with the School of Information Science and Technology, ShanghaiTech University, Shanghai 201210, China, and also with the Shanghai Engineering Research Center of Energy Efficient and Custom AI IC, Shanghai 201210, China (e-mail: hayj $@$ shanghaitech.edu.cn).  

Color versions of one or more figures in this article are available at https://doi.org/10.1109/TCSII.2021.3095764. Digital Object Identifier 10.1109/TCSII.2021.3095764  

# I. INTRODUCTION  

OCALIZATION is one of the most important tasks in smart vehicles. Ideally, it should help smart vehicles to know their current location within a few centimeters and with absolute reliability through different types of perceptual sensors [1]–[4]. Among the localization algorithms, LiDAR-based NDT is widely used due to its robustness and accuracy [5], [6], [7]. NDT algorithm converts the registration of two point clouds to a fitting problem of points and distributions. The fitting problem, as a nonlinear leastsquares issue, can be solved with iterative methods [8], where each iteration contains an enormous number of search operations, and each search operation requires considerable computation.  

It is a great challenge to develop an efficient NDT implementation that can achieve accurate localization in real time [9]. This is because to meet the accuracy requirement of higher speed of smart vehicles, LiDAR point clouds become increasingly large due to the increase of not only the number of laser channels but also their frame rates. For example, the number of laser channels is moving from 64 to 128 or even higher, while the frame rate should be upgraded to at least $30\mathrm{Hz}$ . However, according to experimental results on the datasets with a 64-channels LiDAR, a state-of-theart NDT algorithm [6] can only support less than 2Hz on vehicle-embedded CPU, considerably lower than the real time requirement. As a result, with the upgrading of 3D LiDAR, the pursuit of more channels and higher frame rate will inevitably make NDT algorithm a computationally intensive task that is difficult to be run in real time.  

To meet the real time requirement when implementing an NDT algorithm, previous works have tried to investigate from two directions. On the one hand, they aim to reduce the number of search iterations. Reference [10] proposes multiple-layered NDT to represent the point cloud for fewer iterations and longer distance measurement capabilities. However, it requires too many memories and unacceptable time to update all layers of NDT. Reference [11] improves [10] and presents a key-layered NDT, which meets the termination criteria at a higher layer by only searching the key layer. Unfortunately, their method cannot meet the real-time requirement. On the other hand, they aim to reduce the runtime per iteration. References [12] and [13] extends point-to-distribution NDT to distribution-to-distribution NDT, converting a set of points to distribution for reducing the runtime of each iteration. However, the D2D-NDT approach gets worse accuracy and slower execution time when processing massive and uneven LiDAR point clouds in smart vehicles. Reference [3] proposes semantic-assisted NDT to classify the point clouds and removes the dynamic objects through a segmentation method [2], [14], [15]. Despite that, [3] only removes a limited number of points and requires additional time for point cloud classification. Overall, the above mentioned methods fail to achieve real-time performance when handling large point clouds.  

To address the issue, we propose an efficient NDT implementation on the FPGA platform, which achieves the real-time and high accuracy requirement for 3D-LiDAR localization on smart vehicles. Our contributions are summarized as follows:  

1) We propose a new non-recursive and memory-efficient structure OAVS, which helps to speed up each search operation. Compared with the tree-based structures, the proposed OAVS is easy to parallelize and only accounts for about 1/10 memory consumption.   
2) We propose an SEO-NDT algorithm to significantly reduce the number of search operations. We refine the parameters that affect the number of search operations and remove the redundant search operations.   
3) A streaming FPGA accelerator architecture to further improve the real-time and energy efficiency of the SEONDT algorithm.  

The remainder of this brief is organized as follows. Section II presents SEO-NDT algorithm with OAVS data structure. Section III shows the FPGA implementation of SEONDT algorithm in detail. The experimental results and analysis are given in Section IV. Finally, the conclusion and future work are presented in Section V.  

# II. PROPOSED SEO-NDT ALGORITHM  

In this section, we first give our motivations to improve NDT algorithm and an overview of our proposed SEO-NDT algorithm. Then we introduce how to build and apply the OAVS data structure for fast search. Finally, we present the details of the proposed SEO-NDT algorithm.  

# A. Motivations to Improve NDT  

Let $\mathbf{F}$ and $\mathbf{M}$ be two partially overlapping point clouds, taken from nearby poses. In addition, we define $\mathbf{F}$ to be a fixed (or reference) point cloud, while $\mathbf{M}$ is a moving (or target) point cloud. A registration task estimates a transformation function $\tau$ , such that $\mathcal{T}(\mathbf{M})$ is consistently aligned with $\mathbf{F}$ .  

NDT algorithms attempt to figure out $\tau$ with two steps, namely Initialization and Registration. In the step of Initialization, they first discretize the point cloud space of $\mathbf{F}$ to a set of cells. Then, they calculate the Gaussian distribution of each cell and organize those cells based on the tree-structure method. In the step of Registration, they iteratively project the points in $\mathbf{M}$ to the coordinate of $\mathbf{F}$ , search neighboring cells, compute the probability density and update the gradient and hessian matrix. With those operations, they can fit the point cloud of M with the distributions of $\mathbf{F}$ and obtain the optimal transformation matrix $\tau$ . We define those operations for one point in M as one search operation. However, previous NDT implementations fail to achieve real-time performance when handling large point clouds, because they require an enormous number of search operations and perform intensive computations per search operation. By extensive profiling, our results show that these search operations take up $93\%$ of the execution time of the Registration step. Besides, we find that Initialization does not need to be accelerated. Because Initialization itself can reach a computation frequency of $19\mathrm{Hz}$ , and then treating M of the last Registration as $\mathbf{F}$ of the next Registration, we can compute Initialization only once in two Registration tasks, and the actual frequency can reach $38\mathrm{Hz}$ .  

![](images/644b3ba5b1a5c6d82ff80e08c4b7fbdee89c9562f64fefc476beb0dc5a399648.jpg)  
Fig. 1. An example of constructing the OAVS data structure. (a) Two classes of point clouds. (b) Results of the first segmentation with hash marked in the voxels. (c) Results of the second segmentation with sub_hash marked in the cells. (d) The global first index of the cells in a occupied voxel.  

To efficiently process large point clouds and significantly reduce execution time, we propose an SEO-NDT algorithm with the following optimizations. First, we segment the point clouds $\mathbf{F}$ and $\mathbf{M}$ into different classes of point clouds by the state-of-the-art segmentation method [16]. Second, we replace the tree structure with our proposed OAVS data structure to speed up each search operation. Third, we fit the segmented point cloud of M with the distributions of corresponding sub-point cloud of F. Along with that, we reduce the number of iterations and remove the redundant search operations in the fitting process. Furthermore, taking advantage of the non-recursive characteristic of OAVS, we also accelerate each search operation on FPGA hardware implementation.  

# B. Occupation Aware Voxel Structure (OAVS)  

From the profiling results of the Registration step, we find that the search operations take up nearly $93\%$ of the execution time. Previous works search neighboring cells by recursive tree-structure-based methods, which utilize too much memory and restrict the Registration step to be accelerated. Therefore, it is essential to optimize the neighboring cells searching method. For the K nearest neighbors searching task, [17] shows that double-segmentation-voxel-structure (DSVS) performs better than tree structure on LiDAR datasets. However, DSVS focuses on identifying the dense sub-space and reducing the searching region. Instead, we propose an optimized data structure OAVS for the NDT algorithm.  

OAVS is a hierarchical structure to filter the free space. It supports fast searches by two levels of segmentation. In the first segmentation, a point cloud is segmented into a set of voxels. By counting the number of points in each voxel, the free voxels and occupied voxels are identified. In the second segmentation, the occupied voxels are segmented into several cells that store the Gaussian distribution information.  

Fig. 1 gives an example of constructing a 2D OAVS that consists of three steps. First, Fig. 1(a) shows a labeled point cloud where the black and green represent different classes of points. Second, the point clouds are evenly split into a set of voxels in Fig. 1(b). Those voxels are indexed by hash value and identified by the occupied or free status (hash value of free voxels is marked in Fig. 1(b)). Third, in Fig. 1(c), only the occupied voxels are sub-split into cells indexed by sub_hash (sub_hash of free cells is marked as Fig. 1(c) shows). Fig. 1(d) represents the global first index $f.$ _ind of cells in a voxel, and $^{-1}$ represents a voxel is free. The cell in an occupied voxel (indexed by hash) should be globally indexed by $f\_i n d[h a s h]+$ sub_hash. Take the red point in Fig. 1(b) as an example, we can calculate that the hash value of the point is 7 and the sub_hash value is 1. Therefore, the cell is globally indexed by the f _ind[hash] and the sub-hash, that is, $8+1=9$ .  

Based on the OAVS data structure, we have developed a fast neighboring cells searching method. First, locate the query point with hash and sub_hash value. Second, find the neighboring cells directly in the adjacent $3{^{*}}3{^{*}}3$ cells.  

# C. Proposed SEO-NDT Algorithm  

In this subsection, we first introduce our proposed SEONDT algorithm whose pseudo-code is shown in Algorithm 1. Then, we introduce our two new approaches to reduce the execution time of search operations.  

Algorithm 1 consists of three steps, namely Segmentation, Initialization, and Registration, introduced as follows:  

(1) Segmentation: We segment both $\mathbf{F}$ and $\mathbf{M}$ into $\kappa$ types of points with a state-of-the-art method [16]. Our experiments show that different segmentation methods contribute little for the final speed-up results.  

(2) Initialization: We convert the fixed point cloud $\mathbf{F}$ into distributions with two steps. First, we discretize the point cloud space of $\mathbf{F}$ into a set of cells with the OAVS data structure. Second, we calculate the Gaussian distribution of points for all cells. The Gaussian distribution of each cell $o$ is represented by the mean vector $\mu_{o}$ and the covariance matrix $\Sigma_{o}$ .  

(3) Registration: We match the moving point cloud M with distributions of $\mathbf{F}$ by an iterative method [8]. The while loop will be iterated continuously until $\mathcal{T}(\mathbf{M})$ is consistently aligned with $\mathbf{F}$ . In the while loop body, we first apply $\tau$ for each point $p_{M}^{i}\in M$ to get the projected point $\hat{p}_{M}^{i}$ in the coordinate of F, ˆpiM $\mathbf{\ddot{\widehat{p}}}_{M}^{i}=T(p_{M}^{i})$ . Second, we search the neighboring cells of $\hat{p}_{M}^{i}$ and calculate the probability density of $\hat{p}_{M}^{i}$ by Equ. (1). Third, we construct the optimization function Equ. (2) by updating the gradient matrix $\vec{g}$ and hessian matrix $\mathbf{H}$ [8]. Then, the registration problem is equal to minimizing the optimization function by a transformation matrix $\tau$ . Finally, we solve the optimization function and obtain $\tau$ .  

$$
\begin{array}{r l}&{\rho(\hat{p}_{M}^{i})=\frac{1}{\sqrt{(2\pi)^{3}|\Sigma_{o}|}}\exp\!\left(-\frac{(\hat{p}_{M}^{i}-\mu_{o})^{T}\Sigma_{o}^{-1}(\hat{p}_{M}^{i}-\mu_{o})}{2}\right)}\\ &{\mathrm{~score}=\displaystyle\sum_{p_{M}^{i}\in M}\rho(\hat{p}_{M}^{i})=\displaystyle\sum_{p_{M}^{i}\in M}\rho(\mathcal{T}(p_{M}^{i}))}\end{array}
$$  

Since the Registration step consumes the major part of execution time, we develop two techniques to improve the real-time performance of the NDT algorithm.  

• Reduce the runtime per search operation: When constructing the optimization function (lines 12 to 19 in Algorithm 1), for each point in moving point cloud $M$ , we search the neighboring NDT cells and calculate their probability density. To reduce the runtime of each search operation and maintain the accuracy, we adopt a classified down-sample method. Based on the segmentation result of [16], we further allocate the labeled point cloud with the flags of Refuse $(R)$ , Accept $(A)$ or Down-sample $(D)$ . $R$ means dynamic objects or unlabeled points, which should be Removed to improve the real-time and accuracy. A means structured objects like lanes, poles, and buildings. which should be Accepted. All point clouds with $A$ should be processed with full resolution. $D$ means unreliable or unstructured objects like trees. Those objects will be Down-sampled to reduce the number of points. The down-sample ratio $({\cal R}_{d s})$ is related to the cell size of NDT. Furthermore, as $R_{d s}$ increases, the runtime shows a monotonous decrease trend, and the accuracy shows a change that first increases and then decreases. Since the cell size is fixed to $1.0m$ by the result of [18], we set $R_{d s}=0.3m$ for the optimal accuracy and runtime.  

<html><body><table><tr><td>Algorithm 1: Point Cloud Registration Using SEO-NDT</td></tr><tr><td>Data: fixed point cloud F, target(moving) point cloud M,</td></tr><tr><td>initial transformation Tinit, point cloud detector D Result: A transformation T, s.t T(M) → F</td></tr><tr><td>1 {Segmentation:};</td></tr><tr><td>2 use D to label points in F and M, get labels LF and</td></tr><tr><td>LM with types of label K; 3 {Initialization};</td></tr><tr><td>4 allocate OAVS structure O for F;</td></tr><tr><td></td></tr><tr><td>5 forall labeled points p e F do</td></tr><tr><td>find the cell o' e OF that contains P'; 6</td></tr><tr><td>7 update μv and ∑v for o';</td></tr><tr><td>8end</td></tr><tr><td>{Registration}; o transformation: T  Tinit; 10</td></tr><tr><td>11 while not converged do score ← 0,← 0, H ← 0;</td></tr><tr><td>12 13 foralllabeltypek∈Kdo</td></tr><tr><td>forall points p'M E M with label k do 14 project point p'M with T, PM = T(pM);</td></tr><tr><td>15 search the neighboring cells o' of PM; 16</td></tr><tr><td>17 calculate probability density: p(PM);</td></tr><tr><td>18 update  and H;</td></tr><tr><td></td></tr><tr><td></td></tr><tr><td>19 end end 22end</td></tr><tr><td>20 21 solve H△T =-;T ←T + △T;</td></tr></table></body></html>  

• Reduce the number of search operations: When solving the optimization function (line 20 in Algorithm 1), we use an iterative method whose number of iterations can be reduced to improve the real-time performance. The number of iterations is strongly correlated with the initial step size and exit threshold, denoted as $S_{S t e p}$ and $t_{e x i t}$ , respectively. A good choice of $s_{s t e p}$ enables the iterative search algorithm to approach its optimal result in the first fewer iterations, while a good choice of $t_{e x i t}$ enables the iteration to exit early with negligible loss of accuracy. We find when $S_{S t e p}$ is proportionally adjusted with the speed of a vehicle, Equ. (2) can be solved in the minimum number of iterations. The speed of the vehicle could be measured by an inertial measurement device. We also find that $t_{e x i t}$ could be adjusted with the size of an NDT cell to accelerate the convergence rate while maintaining the accuracy. Therefore, we focus on the step size $s_{s t e p}$ and exit threshold $t_{e x i t}$ to reduce the number of iterations when solving the optimization problem. Analysis of parameters is shown in Section IV.  

![](images/d04d52bce5a3d287e9bd883a96e8fe307406a769c1768308ea719b3680c552b5.jpg)  
Fig. 2. An overview of the FPGA-based SEO-NDT accelerator.  

# III. FPGA-BASED SEO-NDT ACCELERATOR  

To further improve the real-time performance of SEO-NDT, we propose a streaming FPGA accelerator architecture on a heterogeneous system that combines a powerful processing system (PS) and user-programmable Logic (PL). Fig. 2 gives an overview of our FPGA-based SEO-NDT accelerator. On the PL side, we first build the OAVS of segmented fixed point cloud and store the OAVS configurations. Then, when the moving point cloud M is segmented, we perform the search operations and construct the optimization function using OAVS configurations. On the PS side, we segment the point clouds and solve the optimization function because we find those two operations are not computation-intensive tasks through a high Level synthesis (HLS) profiling tool.  

For the I/O interfaces between PS and PL, there are mainly two types of arguments to be transferred. For scalars or small arrays, we merge them into big-size arrays and transfer them via dual-port memory, which is represented in light blue line in Fig. 2. For big arrays, we pack them and implement the interface with direct memory access to obtain the most efficient data transfer, where the streaming type transfer is represented in green line.  

To process the search operations efficiently, we restructure the construction process of the optimization function into three functions and design a dataflow structure based on OAVS as shown in the Search Operation block of Fig. 2. In the first function, we sequentially accept the points from the moving point cloud, project them with the transformation matrix, and locate the cells that contain the projected points. In the second function, we search the neighboring cells of each located cell. In the third function, we compute the probability density of every projected point in neighboring cells, update the gradient and hessian matrix to construct the optimization function. The three functions are balanced to enable task-level pipelining and achieve high performance.  

In addition, we apply a dynamic bit-width optimization strategy to improve the hardware efficiency and simplify the fixed point development [19], [20]. We first fix the bit width of inputs by taking advantage of their detection ranges and precision. Then, we determine the bit-width of critical intermediate variables by evaluating their data ranges along the data path with realistic inputs. In this way, we are able to find the proper bit-widths for all the intermediate floating variables.  

![](images/99b1803faf467be647231a998206057f332e52625037152ef4b961b619d4c120.jpg)  
Fig. 3. The experimental setup is shown in the figure. The left side of the screen shows a segmented point cloud where different colors represent different labels of the point cloud. The right side of the screen shows the trajectory calculated by SEO-NDT on GPU and FPGA, respectively, as well as the actual trajectory.  

# IV. EXPERIMENTAL RESULTS AND ANALYSIS  

# A. Experimental Setup  

To evaluate our method, we choose KITTI [21] (Visual Odometry/SLAM Evaluation 2012 point cloud) as the evaluation dataset. We compare four implementations of the NDT algorithm on different platforms. The first and second are the state-of-the-art method [6] and our proposed SEO-NDT algorithm implemented on ARM, called SE_NDT_ARM and SEO_NDT_ARM, respectively. The third and the fourth are SEO-NDT methods implemented on GPU and FPGA, called SEO_NDT_GPU and SEO_NDT_FPGA, respectively. The GPU implementation is based on the open-source code of [22] with our improvements. All results reported on ARM are measured on Cortex-A53 running at $1300\ \mathrm{MHz}$ . All results reported on GPU are measured based on NVIDIA Jetson Xavier with 512 CUDA cores running at $900\ \mathrm{MHz}$ . All results reported on FPGA are designed with Xilinx SDSOC 2019.1 and measured using a Xilinx UltraScale+MPSoC ZCU102 FPGA board running at 200MHz. The register-transfer level (RTL) code for our FPGA accelerator is generated by Vivado HLS tool. Both the power of GPU and FPGA are measured at chip-level in real time. The power of FPGA and ARM is measured by an embedded sensor INA226 for both PL and PS side. The power of GPU is measured by the Jetson-stats package.  

# B. Selection of Parameters  

This section shows how to select the parameters of exit threshold $t_{e x i t}$ and initial step size $S_{S t e p}$ to obtain the least number of search operations while maintaining accuracy.  

First, we fix the NDT cell size with $1.0\mathrm{m}$ based on the analysis of [18]. From the experimental result, we find as $t_{e x i t}$ increases, the number of search operations decreases monotonically, while the accuracy first maintains unchanged and then decreases. As a result, we have chosen $t_{e x i t}$ to be $0.08\mathrm{m}$ to maintain accuracy and reduce the search operations as much as possible.  

TABLE I RESOURCE UTILIZATION OF SEO-NDT ON XILINX ZCU102   


<html><body><table><tr><td>Resource</td><td>Utilization</td><td>Available</td><td>Utilization (%)</td></tr><tr><td>LUT</td><td>90418</td><td>274080</td><td>32.99</td></tr><tr><td>FF</td><td>93329</td><td>548160</td><td>17.03</td></tr><tr><td>BRAM</td><td>705</td><td>912</td><td>77.30</td></tr><tr><td>DSP</td><td>1213</td><td>2520</td><td>48.13</td></tr></table></body></html>  

TABLE II COMPARISON OF ENERGY EFFICIENCY AND ACCURACY FOR DIFFERENT METHODS ON VARIANT PLATFORMS   


<html><body><table><tr><td>Method</td><td>Power(w)</td><td>tmean(ms)</td><td>EER</td><td>L06O</td><td>H06O</td></tr><tr><td>SE_NDT_ARM [6]</td><td>4.059</td><td>1089.964</td><td>0.226</td><td>0.1957</td><td>0.0174</td></tr><tr><td>SEO_NDT_ARM</td><td>4.050</td><td>428.059</td><td>0.577</td><td>0.1386</td><td>0.0121</td></tr><tr><td>SEO_NDT_GPU [22]</td><td>5.156</td><td>74.244</td><td>2.612</td><td>0.1401</td><td>0.0138</td></tr><tr><td>SEO_NDT_FPGA</td><td>3.984</td><td>30.405</td><td>8.264</td><td>0.1390</td><td>0.0118</td></tr></table></body></html>  

Second, we explore the relationship between the optimal $s_{s t e p}$ and the speed of vehicles. When the speed of vehicles is fixed, as $s_{s t e p}$ increases, the number of search operations first decreases and then increases. The optimal $s_{s t e p}$ corresponds to the minimum number of search operations. When the speed of vehicles is fixed to $10\;\mathrm{km/h}$ , $20~\mathrm{km/h}$ , $30~\mathrm{km/h}$ , and $40~\mathrm{km/h}$ , the optimal $s_{s t e p}$ are $0.23\mathrm{m}$ , $0.27\mathrm{m}$ , $0.35\mathrm{m}$ , and $0.44\mathrm{m}$ , respectively. The $S_{S t e p}$ changes monotonically and nonlinearly with the speed of vehicles. Since the average speed of our tested KITTI dataset is $30\mathrm{km/h}$ , we fix $t_{e x i t}$ to be $0.35\mathrm{m}$ for the least number of search operations.  

# C. Results and Analysis  

Table I shows the resource utilization of SEO_NDT_FPGA algorithm. Table II shows the average power, execution time and consumed energy of localization. We can see that on ARM platform, SEO_NDT gains $2.54\mathrm{x}$ faster than state-of-the-art works. And we can also see that the SEO_NDT_FPGA gains $14.07\mathbf{x}$ faster than SEO_NDT_ARM, that is, totally $35.85\mathrm{x}$ improvement. Besides, the results of the FPGA implementation is better than that of embedded GPU on both power consumption and execution time. When considering the energy efficiency ratio (EER), results show that the FPGA implementation performs the best, which is 14.3 times and 4.95 times that of ARM and GPU implementation, respectively. Furthermore, we also compare the localization accuracy of different implementations as Table II shows. Note that $Q90$ consists of $90_{T}$ and $90_{R}$ , which are larger than $90\%$ of translation error and rotation error, respectively. From the $Q90_{T}$ and $Q90_{R}$ , we can find that the SEO_NDT algorithm also gains a better accuracy because of the reduction of redundant and unreliable points.  

# V. CONCLUSION  

In this work, we propose an optimized FPGA implementation of a real-time NDT algorithm for 3D LiDAR localization of smart vehicles. Our main contribution is to propose a new space-efficient data structure OAVS to efficiently organize NDT cells. Based on this, we also propose a new NDT algorithm SEO-NDT. Using our proposed streaming FPGA accelerator architecture, we have optimized SEO-NDT on FPGA to achieve real-time performance and a better energy efficiency ratio. Compared with the state-of-the-art embedded CPU and GPU implementations, our FPGA implementation achieves up to $35.85\mathrm{x}$ and $2.44\mathrm{x}$ execution time speed up, respectively. In future work, we will explore the theoretical relationship between the optimal initial step size and the speed of vehicles.  

# REFERENCES  

[1] F. Chen, H. Yu, and Y. Ha, “Quality estimation and optimization of adaptive stereo matching algorithms for smart vehicles,” ACM Trans. Embedded Comput. Syst., vol. 19, no. 2, p. 10, 2020. [2] L. Bai, Y. Lyu, and X. Huang, “RoadNet-RT: High throughput cnn architecture and SOC design for real-time road segmentation,” IEEE Trans. Circuits Syst. I, Reg. Papers, vol. 68, no. 2, pp. 704–714, Feb. 2021. [3] A. Zaganidis, A. Zerntev, T. Duckett, and G. Cielniak, “Semantically assisted loop closure in SLAM using NDT histograms,” in Proc. IEEE/RSJ Int. Conf. Intell. Robots Syst. (IROS), 2019, pp. 4562–4568. [4] F. Chen, X. Liu, H. Yu, and Y. Ha, “CLIF: Cross-layer information fusion for stereo matching and its hardware implementation,” in Proc. IEEE Int. Symp. Circuits Syst., 2021, pp. 1–5, [5] M. Magnusson, N. Vaskevicius, T. Stoyanov, K. Pathak, and A. Birk, “Beyond points: Evaluating recent 3D scan-matching algorithms,” in Proc. IEEE Int. Conf. Robot. Autom. (ICRA), 2015, pp. 3631–3637. [6] A. Zaganidis, M. Magnusson, T. Duckett, and G. Cielniak, “Semanticassisted 3D normal distributions transform for scan registration in environments with limited structure,” in Proc. IEEE/RSJ Int. Conf. Intell. Robots Syst. (IROS), 2017, pp. 4064–4069. [7] X. Gu, X. Wang, and Y. Guo, “A review of research on point cloud registration methods,” in Proc. IOP Conf. Series Mater. Sci. Eng., vol. 782, Apr 2020, Art. no. 022070.   
[8] C. Jiang, S. Chen, Y. Chen, D. Liu, and Y. Bo, “A GNSS vector tracking method using graph optimization,” IEEE Trans. Circuits Syst. II, Exp. Briefs, vol. 68, no. 4, pp. 1313–1317, Apr. 2021. [9] Y.-W. Hung, Y.-C. Chen, C. Lo, A. G. So, and S.-C. Chang, “Dynamic workload allocation for edge computing,” IEEE Trans. Very Large Scale Integr. (VLSI) Syst., vol. 29, no. 3, pp. 519–529, Mar. 2021.   
[10] C. Ulas and H. Temeltas, “A fast and robust feature-based scan-matching method in 3D SLAM and the effect of sampling strategies,” Int. J. Adv. Robot. Syst., vol. 10, no. 11, pp. 1–16, 2013.   
[11] H. Hong and B. H. Lee, “Key-layered normal distributions transform for point cloud registration,” Electron. Lett., vol. 51, no. 24, pp. 1986–1988, 2015.   
[12] T. Stoyanov, M. Magnusson, H. Andreasson, and A. J. Lilienthal, “Fast and accurate scan registration through minimization of the distance between compact 3D NDT representations,” Int. J. Robot. Res., vol. 31, no. 12, pp. 1377–1393, Oct. 2012.   
[13] S. Lam, G. Jiang, M. Wu, and B. Cao, “Area-time efficient streaming architecture for fast and brief detector,” IEEE Trans. Circuits Syst. II, Exp. Briefs, vol. 66, no. 2, pp. 282–286, Feb. 2019.   
[14] X. Chang, H. Pan, W. Lin, and H. Gao, “A mixed-pruning based framework for embedded convolutional neural network acceleration,” IEEE Trans. Circuits Syst. I, Reg. Papers, vol. 68, no. 4, pp. 1706–1715, Apr. 2021.   
[15] H. Zhang, Y. Shu, W. Jiang, Z. Yin, W. Zhao, and Y. Ha, “A 55nm, 0.4v 5526-TOPS/W compute-in-memory binarized CNN accelerator for AIoT applications,” IEEE Trans. Circuits Syst. II, Exp. Briefs, vol. 68, no. 5, pp. 1695–1699, May 2021.   
[16] X. Zhu et al., “Cylindrical and asymmetrical 3D convolution networks for LiDAR segmentation,” 2020. [Online]. Available: arXiv:2011.10033.   
[17] H. Sun, X. Liu, Q. Deng, W. Jiang, S. Luo, and Y. Ha, “Efficient FPGA implementation of K-nearest-neighbor search algorithm for 3D LiDAR localization and mapping in smart vehicles,” IEEE Trans. Circuits Syst. II, Exp. Briefs, vol. 67, no. 9, pp. 1644–1648, Sep. 2020.   
[18] S. Pang, D. Kent, X. Cai, H. Al-Qassab, D. Morris, and H. Radha, “3D scan registration based localization for autonomous vehicles—A comparison of NDT and ICP under realistic conditions,” in Proc. IEEE 88th Veh. Technol. Conf. (VTC-Fall), Aug. 2018, pp. 1–5.   
[19] G. Park, D. Im, D. Han, and H. J. Yoo, “A 1.15 TOPS/W energy-efficient capsule network accelerator for real-time 3D point cloud segmentation in mobile environment,” IEEE Trans. Circuits Syst. II, Exp. Briefs, vol. 67, no. 9, pp. 1594–1598, Sep. 2020.   
[20] W. Jiang, H. Yu, X. Liu, H. Sun, R. Li, and Y. Ha, “TAIT: One-shot fullinteger lightweight DNN quantization via tunable activation imbalance transfer,” in Proc. Design Autom. Conf., 2021, pp. 1–6.   
[21] A. Geiger, P. Lenz, C. Stiller, and R. Urtasun, “Vision meets robotics: The KITTI dataset,” Int. J. Robot. Res., vol. 32, no. 11, pp. 1231–237, Sep. 2013.   
[22] K. Koide, M. Yokozuka, S. Oishi, and A. Banno. (2020). Voxelized GICP for Fast and Accurate 3D Point Cloud Registration. [Online]. Available: https://easychair.org/publications/preprint/ftvV  